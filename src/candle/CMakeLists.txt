cmake_minimum_required(VERSION 3.20)

project(Candle VERSION 0.8 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_INCLUDE_CURRENT_DIR ON)

set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${OUTPUT_DIRECTORY})
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${OUTPUT_DIRECTORY})

string(TIMESTAMP DT "%d.%m.%Y - %H:%M:%S")# [<format string>] [UTC])

add_definitions(
    -DBUILD_DATE="${DT}"
    -DsNan=65536
)

find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Core Gui Widgets LinguistTools)
vqt_find_package(REQUIRED COMPONENTS
    Core
    Gui
    LinguistTools
    OpenGL
    PrintSupport
    Script
    SerialPort
    Widgets
)

file(GLOB_RECURSE SOURCES  *.cpp *.h *.ui)
file(GLOB_RECURSE QRC_FILES  *.qrc)
file(GLOB_RECURSE TRANSLATIONS  *.ts)

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    vqt_find_package(COMPONENTS OpenGLWidgets REQUIRED)
endif()

vqt_add_resources(RESOURCES ${QRC_FILES})

#include_directories(
#    ../designerplugins/customwidgetsplugin
#)

if (WIN32)
    # WINDOWS APP ICON
    #set(APP_ICON " myapp.rc")
    add_definitions(-DWINDOWS)
    vqt_find_package(COMPONENTS WinExtras REQUIRED)
    # QMAKE_LFLAGS += "-Wl,--large-address-aware"
    # QMAKE_CXXFLAGS_DEBUG += -g3 -pg
    # QMAKE_LFLAGS_DEBUG += -pg -lgmon
elseif (APPLE)
    # # The MACOSX_BUNDLE_ICON_FILE variable is added to the Info.plist
    # # generated by CMake. This variable contains the .icns file name,
    # # without the path.
    # set(MACOSX_BUNDLE_ICON_FILE photosurface.icns)
    # # And the following tells CMake where to find and install the file itself.
    # set(APP_ICON " resources/photosurface.icns")
    # set_source_files_properties(${app_icon_macos} PROPERTIES
    # MACOSX_PACKAGE_LOCATION "Resources")
    # qt_add_executable(photosurface MACOSX_BUNDLE main.cpp ${APP_ICON})
elseif (UNIX)
    add_definitions(-DUNIX)
    add_compile_options("-Wl,-rpath,\'\$$ORIGIN/libs\'")
endif()

set(PROJECT_SOURCES
    ${APP_ICON}
    ${QRC_FILES}
    ${RESOURCES}
    ${SOURCES}
    ${TRANSLATIONS}
)

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    qt_add_executable(${PROJECT_NAME} MANUAL_FINALIZATION ${PROJECT_SOURCES})
else()
    add_executable(${PROJECT_NAME} ${PROJECT_SOURCES})
endif()

vqt_add_translation(QM_FILES ${TRANSLATIONS})

target_link_libraries(${PROJECT_NAME} PRIVATE
    customwidgets
    ${VQt}::Core
    ${VQt}::Gui
    ${VQt}::PrintSupport
    ${VQt}::Script
    ${VQt}::SerialPort
    ${VQt}::Widgets
)

if (WIN32)
    target_link_libraries(${PROJECT_NAME} PRIVATE
        # setupapi
        ${VQt}::WinExtras
    )
endif()

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    target_link_libraries(${PROJECT_NAME} PRIVATE ${VQt}::OpenGLWidgets)
else()
    target_link_libraries(${PROJECT_NAME} PRIVATE ${VQt}::OpenGL)
endif()

if(QT_VERSION_MAJOR EQUAL 6)
    qt_finalize_executable(${PROJECT_NAME})
endif()

if(WIN32)
    # windeployqt
    set(CMAKE_INSTALL_UCRT_LIBRARIES TRUE)
    get_target_property(_QMAKE_EXECUTABLE ${VQt}::qmake IMPORTED_LOCATION)
    get_filename_component(_QT_BIN_DIR "${_QMAKE_EXECUTABLE}" DIRECTORY)
    find_program(WINDEPLOYQT_EXECUTABLE windeployqt HINTS "${_QT_BIN_DIR}")
    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
        COMMAND "${CMAKE_COMMAND}" -E
        env PATH="${_QT_BIN_DIR}" "${WINDEPLOYQT_EXECUTABLE}"
        --verbose 1
        --no-compiler-runtime
        \"$<TARGET_FILE:${PROJECT_NAME}>\"
        COMMENT "Deploying Qt..."
    )

    #    find_program(LRELEASE_EXECUTABLE lrelease HINTS "${_QT_BIN_DIR}")
    #    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
    #        COMMAND "${CMAKE_COMMAND}" -E
    #        env PATH="${_QT_BIN_DIR}" "${LRELEASE_EXECUTABLE}"
    #        ${TRANSLATIONS}
    #        COMMENT "Deploying Qt..."
    #    )
    #    foreach(QM_FILE ${TRANSLATIONS})
    #        message(WARNING ${QM_FILE})
    #        string(REPLACE ".ts" ".qm" TS_FILE ${QM_FILE})
    #        message(WARNING ${TS_FILE})
    #        file(COPY_PLUGIN ${TS_FILE} DESTINATION ${OUTPUT_DIRECTORY}/translations)
    #        #file(COPY_FILE ${QM_FILE} ${OUTPUT_DIRECTORY}/translations/${FILE_NAME} RESULT res ONLY_IF_DIFFERENT)
    #    endforeach()

elseif (UNIX) #LINUX
#    find_program(Q_MAKE_EXE qmake)
#    find_program(CQT_EXE cqtdeployer)
#    if(NOT EXISTS ${CQT_EXE})
#        message("the cqtdeployer not exits please install the cqtdeployer and run cmake again!")
#        return()
#    endif()
#    add_custom_target(
#        deploy
#        COMMAND cqtdeployer clear -bin ${CURENT_PROJECT} -qmake ${Q_MAKE_EXE} -libDir ${PROJECT_SOURCE_DIR} -qmlDir ${PROJECT_SOURCE_DIR} -recursiveDepth 5
#        COMMENT "Deploy: cqtdeployer clear -bin ${CURENT_PROJECT} -qmake ${Q_MAKE_EXE} -libDir ${PROJECT_SOURCE_DIR} -qmlDir ${PROJECT_SOURCE_DIR} -recursiveDepth 5"
#        WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
#    )
endif()
